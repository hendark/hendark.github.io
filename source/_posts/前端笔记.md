## Vue
### vue安装

``` javascript
npm install -g vue-cli  //安装vue-cli2.0版本
vue init webpack VueProject  //初始化项目
cd cueproject
npm run dev //2.0版本启动项目

npm install -g @vue/cli  //安装vue-cli4.0版本
npm view @vue/cli versions --json  //2.0版本包是vue-cli
npm install -g @vue/cli@版本号  //@vue/cli版本更新是4.0版本，可以用固定版本号下载3.0版本
vue create VueProject //创建3.0版本以上项目
npm run serve //启动项目
```
### vuecli-3.0解析
**vuecli-3.0项目结构简洁：**
``` css
	src：放置组件和入口文件。
	assets：主要存放一些静态图片资源的目录。
 	components：这里存放的是开发需要的的各种组件，各个组件联系在一起组成一个完整的项目。
 	router：存放了项目路由文件。
	App.vue：是项目主组件，也是项目所有组件和路由的出口，之后它会被渲染到项目根目录的 index.html 中显示出来，我们可以在这里写一些适合全局的css样式。
	main.js：入口文件，引入了vue模块和app.vue组件以及路由router，我们需要在全局使用的一些东西也可以定义在这里面。
```
		Vue 在调用 render 方法时，会传入一个 createElement 函数作为参数，也就是这里的 h 的实参是 createElement 函数，这个函数的作用就是生成一个 VNode节点，render 函数得到这个 VNode 节点之后，调用了 mount 方法，渲染成真实 DOM 节点，并挂载到（通常是div app）
		
``` javascript
new Vue({
  router,
  store,//Js文件
  render: h => h(App)
}).$mount('#app')
```

### 父子组件传值
#### 父传子props:{验证传值}
1. 先给父组件中绑定自定义属性
``` javascript
<Child  v-for="item in this.msg" :childData = 'item'/>
```
2. 在子组件中使用props接受父组件传递的数据，可以对传值类型限制,用vue.js
``` javascript
props:{
					childData:{
						type:Array,
						required: true
					}
				}
```
3. 可以在子组件中任意使用	
``` javascript
{{childData.type}}
```
#### 子传父$emit
1. 在父组件绑定自定义事件
``` javascript
template:`
					<div>
						<p>我是一个父组件</p>
						<Child @childHander='childHander'/>
					</div>
				`,
methods:{
					childHander(val){
						console.log(val);
					}
				}
```
2. 在子组件中去触发原生的事件，在函数中使用$emit触发自定义的childHander
``` javascript
template:`
					<div>
						<p>我是一个子组件</p>
						<input type= "text" @input='changValue(childData)'/>
					</div>
				`,
				methods:{
					changValue(val){
						//$emit(自定义事件名，消息)
						this.$emit('childHander',val)
					}
				}
```
### 属性监听
#### 计算属性compute
		模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护，对于任何复杂逻辑，你都应当使用计算属性.
		我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值，否则就会从缓存中返回之前的计算结果，而不必再次执行函数。
``` javascript
汇率： <input type="number" v-model.number="exchange" />
￥: <input type="number" v-model.number = "rmb"  />
//{{}}调用
 $: {{ dollar }}
//计算属性监听
computed:{
			dollar:function(){
				 return this.rmb / this.exchange;
			}
		}
```
#### 侦听属性之watch
		虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。其他用法vm.$watch( expOrFn, callback, [options] )
``` javascript
<p>
    Ask a yes/no question:
    <input v-model="question">
  </p>
  <p>{{ answer }}</p>
  
  watch: {
    // 如果 `question` 发生改变，这个函数就会运行
    question: function (newQuestion, oldQuestion) {
      this.answer = 'Waiting for you to stop typing...'
      this.debouncedGetAnswer()//这里可以调用ajax方法,开销较大的方法
    }
  },
```
#### 自定义指令directive
		Vue 允许注册自定义指令,在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。
**一个指令定义对象可以提供如下几个钩子函数:**
``` yaml
	bind:只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
	inserted:被绑定元素插入父节点时调用 （仅保证父节点存在，但不一定已被插入文档中)。
	update:所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。
	componentUpdated:指令所在组件的 VNode 及其子 VNode 全部更新后调用。
	unbind:只调用一次，指令与元素解绑时调用。
```
**接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。**
``` applescript
	el：指令所绑定的元素，可以用来直接操作 DOM 。
	binding：一个对象，包含以下属性：
		name：指令名，不包括 v- 前缀。
		value：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。
		oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
		expression：字符串形式的指令表达式。例如 v-my-directive="1 + 1" 中，表达式为 "1 + 1"。
		arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 "foo"。
		modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。
	vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。
	oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。
```
自定义指令用例：

``` twig
<div id="div1">
		    <div v-xart>{{num}}</div>
		<button type="button" @click="add">add</button><br><p></p>
		<button type="button" @click="unbind()">接触绑定</button>
</div>
<script>
	function unbind(){
		app.$destroy();//解除绑定
	}
	
Vue.directive('xart', {
		bind: function (el, binding, vnode) {
			console.log(el,binding,vnode)
			console.log('1 - bind')//被绑定
		},
		inserted: function(){
			//绑定到节点
			console.log('2 - inserted')
		},
		update: function (newValue, oldValue) {
			// 值更新时的工作
			// 也会以初始值为参数调用一次
			console.log('3 - update')
		},
		componentUpdated:function(){
			//组件更新完成
			console.log('4 - componentUpdated')
		},
		unbind: function () {
			// 清理工作
			// 例如，删除 bind() 添加的事件监听器
			console.log('5 - unbind')
		},
		})
     
var app = new Vue({
  el: '#div1',
  data:{
		num:1
  },
  methods:{
	  add: function(){
		  this.num++;
	  }
  }
})
</script>
```
#### mixins混入使用
		很多地方都会用到的公用方法，用混入的方法可以减少代码量，实现代码重用。在你已经写好了构造器后，需要增加方法或者临时的活动时使用的方法，这时用混入会减少源代码的污染。
``` xml
	<div id="app">
			<p>num: {{num}}</p>
			<p><button type="button" @click="add">增加数量</button></p>
		</div>
		
	<script type="text/javascript">
		var addLog = {
			data(){
				return{
					num:1
				}
			},
			created(){
				this.hello()
			},
			updated:function(){
				console.log("数据发生变化为"+this.num);   
			},
			methods:{
				hello:function(){
					console.log('mixins中created调用methods')
				}
			}
		}
		new Vue({
			el:'#app',
			methods:{
				add:function(){
					this.num++;
				}
			},
			mixins:[addLog]
		})
	</script>
```

<!--more-->